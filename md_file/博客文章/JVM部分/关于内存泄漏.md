#### REF：[找到了更好的详述内存泄漏的文章](https://github.com/GeniusVJR/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md)

### 什么内存泄漏？
* Android程序内部存在内存回收机制，在不断地进行程序操作时，内存不断地被创建和回收，通过这种模式保证了程序运行的效率
* 而内存泄漏就是原本失去意义应该被回收和释放的内存没有被回收，一直占有程序固有的内存空间。
* 这种不能被回收的内存越来越多的时候，很容易会出现OOM问题。

### 内存泄漏的原因：

#### 根本原因：内存数据一直被某个或某些实例引用，导致了GC不能对其回收，造成内存泄漏
* 出现情形：
* 1. 长生命周期的对象静态引用了短周期的对象，但短周期的对象销毁后，依然被长周期的对象引用，即造成内存泄漏
* 2. 为了保证数据的唯一性和单例性，使用非静态内部类在外部类中创建其静态实例，这样一来该内部类的实例对象就成为一个全周期实例对象，也就是说在外部类中创建的静态内部类实例会一直持有外部类（eg:Activity）的引用，该外部类就会不能正常的回收
* 3.线程操作不同步，在Activity中新建一个线程执行任务，这个线程会持有该Activity的隐式引用，如果Activity被销毁，而线程任务没有执行完毕,则该线程会一直持有该Activity的引用，系统无法回收该Activity的资源
* 4.Handler机制在不断轮询的过程中，如果Activity被销毁，但消息队列中还有未执行完毕的消息，那么该消息队列就会一直持有Activity的应用，无法回收
* 5.对于BraodcastReceiver,ContentProvider,File,IO流，Cursor等需要手动关闭和注销的对象，如果没有即时销毁和注销，否则这些对象将不会回收

#### 如何避免内存泄漏？
##### 根本理念：合理设计程序对象的运行周期和运行区域，严格按照数据对象的操作方法，即时注销和销毁无用的对象（不能出现被引用的对象不能出现被销毁了引用对的相关操作还没有执行完毕的情况）

> 引申出来需要具体学习的模块：
> * [静态方法实现弱引用](http://blog.csdn.net/watermusicyes/article/details/45898793)
> * [AS中分析内存泄漏方法](http://www.jianshu.com/p/c49f778e7acf)
> * 熟悉各项对象是否需要手动注销和释放
