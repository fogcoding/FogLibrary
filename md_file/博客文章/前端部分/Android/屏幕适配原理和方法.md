### [屏幕适配全攻略-世界是我的床（简书作者）](http://www.jianshu.com/p/6319e43572fa)

#### 个人笔记：
> * dip：Density Independent Pixels（密度无关像素）的缩写。以160dpi为基准，1dp=1px
> * dp：同dip
> * dpi：屏幕像素密度的单位，“dot per inch”的缩写
> * px：像素，物理上的绝对单位
> * sp：Scale-Independent Pixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，通常可以使用12sp，14sp，18sp，22sp，最好不要使用奇数和小数。

##### 总结：
> * 屏幕适配就是希望通过一些合理的设计摆放计算规则，使得一套UI设计能够在各种不同分辨率的屏幕上呈现相同的显示效果
> * 实现屏幕适配的途径是借助像素密度（DPI），任何设备有确定的物理屏幕尺寸和分辨率大小，不同的尺寸和分辨率的设备通过反向计算DIP/DP即能实现
> * 计算规则：DP/DIP以160DPI为基础，此时 1DP=1PX，然后不同的DPI的值对DP对应的像素值按照 适配设备的DPI值/160×DP值=适配设备上的实际像素值 

##### 适配的简单方法：
> * 按照总结说的设计DP的值，依据不同设备的DPI的值转换成对应的设备情况的像素值，完成UI适配
> * 使用layout_weight值按比例分割空间，结合固定DP值的方法

##### layout_weight值计算方法：
> 对于统一宽高空间的控件设置layout_weight值，以父容器的宽度为例，例如：layout_weight=“1”；layout_weight=“2”；
> 那么父容器的宽度会被分割成均等三份，layout_weight=“1”的控件占据1/3，layout_weight=“2”的控件占据2/3，（前提：这两个控件的宽度要设置为0）

> 因为权重分割的计算方法为：所占宽度=原来宽度+剩余空间所占百分比的宽度

> 当两个控件宽度设置为0 DP，而对于layout_wight=1的控件对应的计算公式为：0+L（1/（1+2））=1/3L

> 当两个控件的宽度设置为充满父容器时，对于layout_wight=1的控件对应的计算公式会变成：L + (L-(L+L))*(1/(1+2))= L - L/3 = 2/3L 

> *以上的两种不同的结果，可以看出，我们一定要注意正确的理解和运用公式，否则会出现完全无法理解的情况！*

##### 9.patch 已基本熟悉和理解运用，相当熟练，仅作记载

#### 软件自适应用户界面的方法：
> * 1.根据使用设备的参数信息设计程序执行入口，每次执行之前进行判断，确保选择使用合适的用户界面参数，

> 这种方法需要在代码中添加很多冗长的环节和逻辑

> * 2.使用工厂模式，先为各种情况下的UI界面设计好相应的参数信息，然后在执行程序的时候判断设备类型，加载对应的参数，完成适配

> 这种方法在于编写各种对应的参数文档比较繁琐，但在程序设计的时候，相当简单


###### 适配UI的时候，有一个问题需要特别关注：UI界面多数需要提供图片和背景素材，然而图片会占用很大的内存，很不利于APP轻量化和瘦身
> * 一张图片可以用来适配所有的屏幕密度情况，但是每种图片对应的屏幕密度规格各有不同
> * 以Nexus5为例，如果我们把图片放在drawable-xxhdpi下，占用的内存最小（10M+），如果放在drawable或drawable-mdpi下，占用的内存将会非常大（75M+）。如果放在drawable-hdpi下占用的为35M+（同一张图片）
> * 所以，我们可以根据需要提供不同尺寸的图片，用来适配不同的屏幕密度，避免造成很大程度上浪费内存。

###### PS：不同的DPI图片会在适配时有不同的显示效果，但简单的轻量化无法满足UI设计需求时，有必要放弃小内存图片


### 使得一套UI设计参数能够在所有设备显示出同样的效果的方法：
> * 1.获取设备的分辨率大小，设定自定义的宽高大小，例如：320X480 （无单位），仅仅代表将设备的像素值均分的份数
> * 2.设计算法，根据设备的分辨率按照自定义的宽高大小均等分割像素值，获取到自定义大小所代表的实际像素值
> * 3.我们根据自定义像素值的大小来设计UI界面，使得我们给出的大小在实际的设备上都是占有的百分比大小，这样就能适应所有的设备界面

##### 这种办法其实就是DP值适配的原理，对于标准的DPI屏幕，没有必要再自行设计，但是这种思路可以用来实现一些并非标准DPI的屏幕的适配，是一个用来解决偏门问题的备用选项
