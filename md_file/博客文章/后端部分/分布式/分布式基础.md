## 分布式基础



#### 分布式需要解决的关键问题

```shell
首先，分布式系统中故障是常态

1.API网关
2.通信机制:，http,rpc
3.服务注册与发现
4.熔断机制

三种解决方案：
1.spring Cloud netflix
2.dubbo+zookeeper
3.springcloud alibaba


```



#### 常见面试题

```

-- 微服务部分
1.什么是微服务？
2.微服务之间如何通讯？
3.SpringCloud和Dubbo之间有哪些区别？
4.SpringBoot和SpringCloud,请谈谈你对他们的理解
5.什么是服务熔断?什么是服务降级？
6.微服务的优缺点是什么？说下你在项目开发下遇到的坑
7.你所知道的微服务技术栈有哪些？请列举一二
8.eureka和zookeeper都可以提供服务注册和发现功能，请说说两个的区别？


-- zookeepr 部分
1.为什么说zookeeper集群的机器数一般是奇数，可以是偶数吗？
2.从CAP角度下分析zookeeper和SpringCloud eureka的区别？
3.Zookeeper的ZAB协议是什么？
4.zookeeper的脑裂是什么？



```



#### Dubbo部分

```shell
## Dubbo的部分的基础知识

## dubbo是什么？能做什么？
阿里巴巴开源给apache的一个高性能rpc服务框架，目标是提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。

核心部分：
1.远程通讯：提供多种基于长连接的NIO框架抽象封装，包括多线程模型，序列化，以及请求-响应模式的信息交互方式，透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何的API侵入。
2.集群容错：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持，可在内网用于替代F5等硬件负载均衡器，降低成本，减少单点。
3.自动发现：基于注册中心目录服务，服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者

## dubbo支持什么协议？
Dubbo3 提供了 Triple(Dubbo3)、Dubbo2 协议，这是 Dubbo 框架的原生协议。
除此之外，Dubbo3 也对众多第三方协议进行了集成，并将它们纳入 Dubbo 的编程与服务治理体系， 包括 gRPC、Thrift、JsonRPC、Hessian2、REST 等

RPC 协议的设计需要考虑以下内容：
通用性： 统一的二进制格式，跨语言、跨平台、多传输层协议支持
扩展性： 协议增加字段、升级、支持用户扩展和附加业务元数据
性能：As fast as it can be
穿透性：能够被各种终端设备识别和转发：网关、代理服务器等 通用性和高性能通常无法同时达到，需要协议设计者进行一定的取舍


# 1.Dubbo的架构层级
1.服务代理层  Proxy   支持JDK动态代理，javasist等代理机制
2.注册中心层  Registry   支持Zookeeper，redis等作为注册中心
3.远程调用层  Protocol   远程调用层，支持dubbo,http等调用协议
4.网络传输层  Transport  支持netty,mina等网络传输框架
5.数据序列化层  Serialize   支持json，hessian等序列化框架

## Dubbo与springCloud的区别
1.dubbo由于是二进制传输，占用带宽会更少，SpringCloud是http协议传输，且多使用json报文，带宽消耗更大
2.dubbo的开发难度更大，原因是dubbo的jar依赖问题很大大型的工程无法解决
3.SpringCloud的接口协议比较自由且松散，需要强有力的行政措施来限制接口的无序升级
4.dubbo只是springCloud的一个子集，解决的是分布式中微服务调用问题，而SpringCloud提供了全套的解决方案.

## dubbo集群的容错策略有哪些？
Failover cluster: 失败自动切换  dubbo默认方案，当调用失败后自动切换到其他可用节点，具体的重试间隔和重试次数可以通过引入服务的时候配置，默认重试次数为1也就是只调用一次。
Failback cluster: 失败自动恢复 在调用失败，记录日志和调用信息，然后返回空结果给consumer，并且通过定时任务每隔五秒对失败调用进行重试
failfast cluster: 快速失败  只会调用一次，失败后立刻抛出异常
failsafe cluster: 失败安全  调用异常，记录日志不抛出，返回空结果
forking cluster:  并行调用多个服务提供者，通过线程池创建多个线程，并发调用多个provider，结果保存到阻塞队列，只要有一个provider成功返回了结果，就会立刻返回结果
Broadcast cluster:  逐个调用每个provider，如果去其中一台报错，在循环调用结束后，抛出异常

## dubbo如何进行服务调出的？
1.首先dubbo会将程序员所定义的@DubboService或@Service等注解进行解析，得到程序员定义的服务参数，包括定义的服务名，服务接口，服务超时时间，服务协议等等得到一个ServiceBean
2.然后调用ServiceBean的export方法进行导出
3.然后将服务注册到注册中心，如果有多个协议，多个注册中心就进行单个协议，单个注册中心的分别注册
4.将服务注册到注册中心后，还会绑定一些监听器，监听动态配置中心的变更
5.还会进行服务协议启动对应的web服务器和网络框架，比如Tomcat和netty等

## dubbo是如何进行服务引入的？
1.当程序员使用一个@Reference注解来引入一个服务时，Dubbo会将注解和服务的信息解析出来，得到当前所引用的服务名，服务接口是什么？
2.然后从注册中心进行服务查询，得到服务提供者的信息，并存在消费端的服务目录中，并且绑定一些监听器来获取配置中心的变更情况
3.再根据查询得到的服务提供者信息生成一个服务接口的代理对象，并放入spring容器中作为Bean


## dubbo支持哪些注册中心？
1.zookeeper （官方推荐）
  优点：支持分布式
  缺点：受限于Zookeeper的特性
2.redis
  优点：支持集群，效率高
  缺点：要求服务器时间同步，否则会出现集群失败问题
3.Multicast
  优点：去中心化，不需要独立安装组件
  缺点：Provider和Consumer和Registry不能跨机房（路由）
  不需要启动任何中心节点，只要广播地址一样，就可以互相发现，组播受网络结构限制，只适合小规模应用和开发阶段使用
4.Simple
  优点：标准RPC服务，没有兼容问题
  缺点：不支持集群
  
  
  ## dubbo支持哪些负载均衡策略？
  1.随机: 从多个服务提供者随机选择一个来处理本次请求，调用量越大则分布越均匀，并支持按权重设置随机概率
  2.轮询：依次选择服务提供者来处理请求，并支持按权重进行轮询，底层采用的是平滑加权轮询算法
  3.最小活跃调用数：统计服务提供者当前正在处理的请求，下次请求过来直接交给活跃数最小的服务器来处理 
  4.一致性哈希：相同参数的请求总是发送到同一个服务提供者
  
  
```

