## JAVA集合框架
* list 列表

* set 

* map 映射

	这些数据结构都是继承自collection实现的数据结构类型，他们不是简单的规定了存储的数据类型的数据容器，这些容器的形式就是实现了一个特定的数据结构。

### List
* ArrayList ：底层基于数组的list数据结构
* LinkedList ：底层基于链表的list数据结构
* ArrayList和LinkedList性能状况：
 1. 查找索引性能：由于可以直接根据“下标值”来引用，ArrayList的索引效率较高，而LinkedList每次查找都要走过每一个索引值之前的数据内容，效率较低
 2. 删除修改效率：由于链表的修改只需要修改数据内容，其他的数据无需改变，所以效率较高，而数组执行删除操作后，需要将之后的每个元素前移一位，存在隐形的操作需求，效率较低
 3. 总结起来就是：数组结构查找更快，链表结构修改更快



---

### set 

* HashSet特点： 

1. 底层数据是HashMap，只是操作的都是key，value的值恒为null
2. hashset与数组相反，基于hash算法的实现方式，无法保存顺序
3. 总结:HashSet就是给予hash算法存储的一对对没有值，只有key的HashMap



* TreeSet特点： 

1. 底层数据是TreeMap，只是操作的都是key，value的值恒为null
2. 同TreeMap一样，都是基于树实现，对象按升序存储，可以实现快速访问和检索
3. 同TreeMap，存入的数据也要实现Comparable接口，提供排序方法



总结:TreeSet就是基于树的算法，存储的一对对没有值，只有key的TreeMap



### map

---

* HaspMap 

1. 基于hash表的数据结构,Hashmap中是一对对<key,value>

2. 而存储的方法是利用hash算法，计算f(key)，得到一个值，存在内存地址里的对应位置，但不同的key可能得到同样的hash值，这样的情况会把后放进去的<key,value>存放在对应的位置，先放进去的<k,v>以链表的形式存放在后面

3. 由于按照hash值来存储,所以不能保留数据存放的先后顺序

   

   总结来说，hashmap的数据结构就是数组加链表

* Hash碰撞的发生情景与处理流程
  1. 如何发生？
  
     所谓的hash碰撞，就是不同对象经过hash计算会取到相同的散列表下标，造成位置冲突
  
     当散列表要插入的位置已经存在一个数据，而原来存在的key与要插入的key无论是==还是equals都会得到false的结果，就会进入链表next存储操作，这样的情况就是发生了hash碰撞。
  
  2. 发生后如何处理？
  
     数据的存储在那个发生冲突的位置使用next的链表指针形式存储数据，而要解决这个问题，改变hash表的长度应该是可以。
  
  3. 如何避免？
  
     对hashcode方法和equals方法引起警惕和警觉，避免对象不同却取得相同的hash值。   
  
     
  
* hash碰撞会有什么影响？

  1. 对于数据的存储和获取功能，毫无影响
  2. 由于从散列表添加了链表的数据结构形式，会对hash表的存取性能产生影响



* TreeMap

1. 基于红黑树实现的数据结构，不像hash映射，树映射保证元素是按照关键字的升序排列，所以可以实现快速检索

2. 若是自定义的类存入TreeMap，那么该类需要实现Comparable接口，给出排序规则，是的红黑树算法可以实现

   

   总结来说，就是将键值对的数据以红黑树的形式储存，并实现快速检索





---
#### 处理与hashCode的规范（源自java虚拟机的机制）

1.JAVA程序运行时，多次调用同一对象的hashCode()方法必须是返回相同的整数

* 这条原则的前提是：一个对象没有被修改任何信息！即，一个对象没有改变却会得到不同的hashcode的情况不允许！（这里的要求来源于java虚拟机对于对象的加载和管理机制）

* 这里表示的是程序的一次运行期间，而多次运行期间无需保持相等 

2.如果使用equals方法判断两个对象是相等的，那么这两个对象的hashCode也要保持相等

