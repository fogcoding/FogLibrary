## 多线程基础









#### 线程变量ThreadLocal

##### 典型场景：Android中的Looper对象与线程的对应

​	Looper的作用域就是线程，那么与线程直接对应的ThreadLocal可以很轻松地实现looper所需要的功能。

##### 典型场景：复杂逻辑下的对象传递

​	比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？

​	其实就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。

而如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法：

​	第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，

​	第二种方法就是将监听器作为静态变量供线程访问。

​	上述这两种方法都是有局限性的。

​	第一种方法的问题时当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。

​	第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如如果同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal每个监听器对象都在自己的线程内部存储，根据就不会有方法2的这种问题。

