#### [REF:视觉直观感受 7 种常用的排序算法](http://blog.jobbole.com/11745/)

## 时间时间复杂度和空间复杂度：用来衡量算法优劣的依据
* 时间复杂度：执行算法所需要的计算次数
* 空间复杂度：执行这个算法所需要的内存空间
* 

## 排序算法总结：
* 选择排序
> 先遍历整个数组找到最小的放在最前面，再寻找第二小的放在第二位，依次类推，直到所有数据被操作一遍
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms4.gif)

* 插入排序
> 1.先取第一个元素，认为这个元素就是一个“已经排序的数组”，
> 2.将第二个元素在“已经排序的数组”里面找到合适的位置插入（大在后，小在前），再将第三个元素插入合适的位置，
> 3.依次类推，直到所有的数据都被放入“已经排序的数组”，排序完毕

* 快速排序
> 1.在要排序的数据中选一个大小居中的值为标准，比他大的放右边，小的放左边，将数据分成两组，
> 2.再对左右的两组数据重复第一步骤，所得的数据模块也重复第一步骤，直至完成
> 效果示意图：
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms.gif)


* 归并排序
> 1.根据数据总体的容量，选择将总体数据分成N个容量相等的子数据模块，
> 2.依次选取第1，2，两个子模块，对子模块内部数据各自先进性排序，再将排序后的两个子模块合并，
> 合并时设置两个子模块最小值为起始点（指针），小的放前面，依次后移起始点的位置，完成两个子模块的合并排序，
> 3.在3，4子模块重复2步骤，然后将3，4合并后的模块与1，2生成的模块再次合并，
> 4.依次类推···
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms2.gif)

* 堆排序
>
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms3.gif)

* 基数排序（分LSD和MSD两种）
>

* STD::SORT(c++ STL)
* STD::STABLE SORT(c++ STL)
* 希尔排序
>
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms6.gif)

* 冒泡排序
>
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms5.gif)

* 鸡尾酒排序（双向冒泡排序）
> 

* gnome排序（地精排序）
>

* bitnioc（双调排序）
>

* Bogo排序（猴子排序）
>

### [排序执行的具体过程视频](http://v.youku.com/v_show/id_XNTkwNzI5OTIw.html)

