#### [REF:视觉直观感受 7 种常用的排序算法](http://blog.jobbole.com/11745/)

## 时间时间复杂度和空间复杂度：用来衡量算法优劣的依据
* 时间复杂度：执行算法所需要的计算次数
* 空间复杂度：执行这个算法所需要的内存空间
* 

## 排序算法总结：
* 选择排序
 
> 先遍历整个数组找到最小的放在最前面，再寻找第二小的放在第二位，依次类推，直到所有数据被操作一遍

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms4.gif)

* 插入排序

> 1.先取第一个元素，认为这个元素就是一个“已经排序的数组”，

> 2.将第二个元素在“已经排序的数组”里面找到合适的位置插入（大在后，小在前），再将第三个元素插入合适的位置，

> 3.依次类推，直到所有的数据都被放入“已经排序的数组”，排序完毕

* 快速排序

> 1.在要排序的数据中选一个大小居中的值为标准，比他大的放右边，小的放左边，将数据分成两组，

> 2.再对左右的两组数据重复第一步骤，所得的数据模块也重复第一步骤，直至完成

> 效果示意图：

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms.gif)


* 归并排序

> 1.根据数据总体的容量，选择将总体数据分成N个容量相等的子数据模块，

> 2.依次选取第1，2，两个子模块，对子模块内部数据各自先进性排序，再将排序后的两个子模块合并，

> 合并时设置两个子模块最小值为起始点（指针），小的放前面，依次后移起始点的位置，完成两个子模块的合并排序，

> 3.在3，4子模块重复2步骤，然后将3，4合并后的模块与1，2生成的模块再次合并，

> 4.依次类推···

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms2.gif)

* 堆排序

> 堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点，

> 也就是说堆排序是根据二叉树的特性产生的算法，它并不是一个普适性的算法

> 二叉树形式的数据结构，本身遵循了一定的大小规则，可以认为二叉树的数据结构是一个另一种形式sorted data,而堆排序就是将二叉树转化成数组形式

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms3.gif)

* 基数排序（分LSD和MSD两种）
>

* STD::SORT(c++ STL)
* STD::STABLE SORT(c++ STL)
* 希尔排序
>
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms6.gif)

* 冒泡排序
>
![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms5.gif)

* 鸡尾酒排序（双向冒泡排序）
> 

* gnome排序（地精排序）
>

* bitnioc（双调排序）
>

* Bogo排序（猴子排序）

> 在很久很久以前，有人讲，让许许多多的猴子操作打字机，一直打字，当猴子足够多，时间足够长的时候，猴子即使完全不认字，他们也一定打印出了莎士比亚的文学作品内容，表达了程序员对乱枪打鸟算法的深刻理解！老夫简直目瞪口呆！

> 这种排序的具体操作方式就是，先随机打乱数组，随机排列一遍，检测是否符合排序要求，检测不符合，继续打乱继续随机排列，

> 无限循环，总有一次是符合要求的吧！

> #### 【目瞪口呆.jpg】

> ##### PS：老子一本正经学代码，严肃的很，结果学到了这个，我感受到了深深的恶意！！！！！！！！！！！

### [排序执行的具体过程视频](http://v.youku.com/v_show/id_XNTkwNzI5OTIw.html)
> ps:这是一个直观体现排序过程从数据变动的视频，相当清晰明白的表现了数据的变化情况，算法性能

