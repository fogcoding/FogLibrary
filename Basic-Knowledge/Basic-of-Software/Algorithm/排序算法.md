### [REF:视觉直观感受 7 种常用的排序算法](http://blog.jobbole.com/11745/)

## 时间时间复杂度和空间复杂度：用来衡量算法优劣的依据
* 时间复杂度：执行算法所需要的计算次数
* 空间复杂度：执行这个算法所需要的内存空间
* 

## 排序算法总结：
* 选择排序
 
> 先遍历整个数组找到最小的放在最前面，再寻找第二小的放在第二位，依次类推，直到所有数据被操作一遍

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms4.gif)



* 插入排序

> 1.先取第一个元素，认为这个元素就是一个“已经排序的数组”，

> 2.将第二个元素在“已经排序的数组”里面找到合适的位置插入（大在后，小在前），再将第三个元素插入合适的位置，

> 3.依次类推，直到所有的数据都被放入“已经排序的数组”，排序完毕



* 希尔排序

> 插入排序在已经排序过的数组中执行起来相当优秀，但一个完全没有排序的数组却表现不好，因为插入排序每次只能将数据量移动一位

> 希尔排序就是针对插入排序的问题得出的改进算法，但是这是一个不稳定的算法

> 1.先将要排序的一组数按某个间距d分成若干组，每组中记录的数据的下标相差d,对每组中元素进行排序，

> 2.然后再用一个小一点间距再执行一次，在每组中再进行排序。

> 3.当增量减到1时，整个要排序的数被分成一组，排序完成。

> ps:这种方法的优点就是比较较远距离的两个数的大小，然后排序，可以节省很多次的比较和交换操作，大大提升程序效率

![示例图](http://h.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=64f173189145d688b70fbaf6c5ab167b/b3fb43166d224f4a87a8c9380af790529822d1ec.jpg)

![数据变化情况示意图](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms6.gif)



* 快速排序

> 1.在要排序的数据中选一个大小居中的值为标准，比他大的放右边，小的放左边，将数据分成两组，

> 2.再对左右的两组数据重复第一步骤，所得的数据模块也重复第一步骤，直至完成

> 效果示意图：

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms.gif)




* 归并排序

> 1.根据数据总体的容量，选择将总体数据分成N个容量相等的子数据模块，

> 2.依次选取第1，2，两个子模块，对子模块内部数据各自先进性排序，再将排序后的两个子模块合并，

> 合并时设置两个子模块最小值为起始点（指针），小的放前面，依次后移起始点的位置，完成两个子模块的合并排序，

> 3.在3，4子模块重复2步骤，然后将3，4合并后的模块与1，2生成的模块再次合并，

> 4.依次类推···

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms2.gif)




* 堆排序

> 堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点，

> 也就是说堆排序是根据二叉树的特性产生的算法，它并不是一个普适性的算法

> 二叉树形式的数据结构，本身遵循了一定的大小规则，可以认为二叉树的数据结构是一个另一种形式sorted data,而堆排序就是将二叉树转化成数组形式

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms3.gif)



* 冒泡排序

> 每次都从第一个元素开始，依次与后面的元素比较，比后面的元素大就向后移动，小就进入下一轮比较，依次类推

![](http://jbcdn2.b0.upaiyun.com/2012/01/Visual-and-intuitive-feel-of-7-common-sorting-algorithms5.gif)




* 鸡尾酒排序（双向冒泡排序）

> 1.左右两边同时开始，一方比较小的放左边，一方比较大的放右边，

> 2.按照冒泡的执行步骤，循环执行，直至排序完成

> ps:对比冒泡可以获得稍微高一点的效率，因为一次循环执行了两次操作，但提升有限



* gnome排序（地精排序）

> 号称最简单的排序，只有一层循环。

> 设置遍历数组的索引值，默认往前冒泡,一旦遇到冒泡的情况发生就往回冒,直到索引值走完整个数据空间（int i=0，一个数组10个数，但i<10不满足时，跳出循环）

> 具体的执行步骤是：

> 1.从第一个数开始执行冒泡操作，

> 2.当发生了交换位置的操作，则索引值-1，若不发生交换则索引值+1，

> 其效果就是将交换后的数据作为新的冒泡起始点，若是大的放右边的冒泡方式，表现结果就是不断的将小的数往左边放，放在左边的数又开始执行冒泡操作

> PS：这个算法的好处就是能够充分体现CPU的效率，因为只有一次循环，一直在执行，不同效率的CPU可以得到直观的体现



* bitnioc（双调排序）
>

* 基数排序（分LSD和MSD两种）
>

* STD::SORT(c++ STL)
* STD::STABLE SORT(c++ STL)



* Bogo排序（猴子排序）

> 在很久很久以前，有一个伟大的程序员讲，让许许多多的猴子操作打字机，一直打字，当猴子足够多，时间足够长的时候，猴子即使完全不认字，他们也一定打印出了莎士比亚的文学作品内容，表达了程序员对 **乱枪打鸟算法** 的深刻理解！老夫简直目瞪口呆！

> 这种排序的具体操作方式就是，先随机打乱数组，随机排列一遍，检测是否符合排序要求，检测不符合，继续打乱继续随机排列，

> 无限循环，总有一次是符合要求的吧！

> #### 【目瞪口呆.jpg】

> ##### PS：老子一本正经学代码，严肃的很，结果学到了这个，我感受到了深深的恶意！！！！！！！！！！！

### [排序执行的具体过程视频](http://v.youku.com/v_show/id_XNTkwNzI5OTIw.html)
> ps:这是一个直观体现排序过程从数据变动的视频，相当清晰明白的表现了数据的变化情况，算法性能

