## JVM的调优的概念


## JVM调优常见设置汇总
* 堆设置
> * -Xms：初始堆大小
> * -Xmx：最大堆大小
> * -XX:NewSize = N: 设置年代大小
> * -XX:NewRatio = N: 设置年轻代和年老代的比值
> * -XX:MaxPermSize = N: 设置持久代大小

* 收集器设置
> * -XX:+UseSerialGC:设置串行收集器
> * -XX:+UseParallelGC:设置并行收集器
> * -XX:+UseParalledlOldGC:设置并行年老代收集器
> * -XX:+UseConMarkSweepGC:设置并发收集器

* 垃圾回收统计信息
> * -XX: +PrintGC
> * -XX: +PrintGCDetails
> * -XX: +PrintGCTimeStamps
> * -Xloggc:filename

* 并行收集器设置
> * -XX: ParallelGCThreads = N:设置并行收集器收集时使用的CPU数（并行收集线程数）
> * -XX: MaxGCPauseMillis = N:设置并行收集最大暂停时间
> * -XX: GCTimeRatio = N:设置垃圾回收时间占程序运行的百分比。公式为1/（1+n）

* 并发收集器设置
> * -XX: CMSIncrementalMode:设置为增量模式，适用于单CPU情况。
> * -XX: ParallelGCThreads = N:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

## 对于调优设置的总结
* 年轻代大小选择
> * 响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据时间情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时减少到年老代的对象。
> * 吞吐量优先级的应用：尽可能的设置大，可能到达GBit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

* 年老代大小选择
> * 响应时间优先的应用：年老代使用的并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片，高回收频率以及应用暂停而使用传统的标记清楚方式；如果堆大了，则需要较长的收集时间。
> * 最优化的方案，一般需要参考以下数据：
> * 1.并发垃圾收集信息
> * 2.持久代并发收集次数
> * 3.传统GC信息
> * 4.花在年轻代和年老代回收上的时间比例
> > PS:减少年轻代和年老代话费的时间，一般会提高应用的效率

* 吞吐量优先的应用
> * 一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能的回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象

* 较小堆引起的碎片问题
> * 碎片产生原因：年老代并发收集器使用标记、清除算法，所以不会对堆进行压缩
> * 配置方法：
> * 1.-XX: +UseCMSCompactAtFullCollection:使用并发收集器时，开启对年老代的压缩
> * 2.-XX: +CMSFullGCsBeforeCompaction = 0:在配置1开启的情况下，这里设置多少次Full GC之后，对年老代进行压缩

---
### 垃圾回收的瓶颈：传统回收方式的Full GC请求会带来应用暂停，分代垃圾回收方式的区域分代会限制应用处理数据量的大小，即使配合并发回收器，效果也并不理想

### 瓶颈突破的解决办法：
* 增量收集

> * 增量收集把对堆空间划分成一系列内存块，使用时，先使用其中一部分（不会全部用完），垃圾收集时把之前用掉的部分中存活的对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免传统分代方式整个使用完了再暂停回收的情况（传统分代收集最大的劣势就是整个堆是一块内存，最终会造成“碎片”无法压缩，另一方面每次收集都是对整个堆的收集，无法进行选择，在暂停时间的控制十分弱）。

---

