### 多线程编程的实现工具：
> * *Thread,Runable* 此方法是其他方法的基础和原理，任何有关线程操作的封装类和框架都是通过内部操作Thread对象来实现的
> * *Asynctask* [Asynctask的使用-自己的博客](http://www.cnblogs.com/thinfog/p/5648312.html)
> * *Handler,looper,MeasageQueue* [Android异步消息机制-郭霖](http://blog.csdn.net/guolin_blog/article/details/9991569)

#### 线程和进程的关系：
> * 进程是系统内存分配的最小单位，线程是程序执行的最小单位
> * 一个进程代表系统为一个程序开辟内存空间，加载需要操作的代码，进程空间，数据空间，打开的文件等程序需要操作的相关区域和程序执行需求
> * 一个进程可以包含一个或多个线程，每个线程会加载CPU的寄存器，堆栈，处理器资源，这些进程包含的所有线程都是分割系统为此进程开辟的操作空间和内存空间里，抢占式地在CPU里进行执行

#### 线程和进程在CPU硬件和系统进程管理中的表现形式：
> * [线程和进程在操作系统中的表现形式](http://blog.csdn.net/luoweifu/article/details/46595285)

#### 线程锁和数据同步：

* [Java中synchronized关键字的使用](http://blog.csdn.net/luoweifu/article/details/46613015)
*  synchronizedde的作用域：

> * 1.修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 

> * 2.修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；

> * 3.修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；

> * 4.修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象

###### 锁的心得记录：

> 1.被同步锁修饰的代码块只有获得同步锁的程度段可以执行，而且同步代码块只会产生一把锁

> 2.一个方法被同步锁修饰后，与同步代码块类似，只有获取方法同步锁的程度段可以执行它，同步方法也只能有一把锁与之关联

> 3.静态方法属于类本身，一个类是独一无二的对象模板，所以同步锁修饰静态方法意味着无论这个类的对象实例有多少，静态方法的锁只有一把，所有对象的静态方法块操作是同步的。对比来说，同步锁只修饰类中的部分代码块和方法时，由于类创造了不同的实例对象而产生了各自的同步锁，从而失去了同步的作用。

> 4.如果对一个类加上同步锁，那么这个类的所有对象都共享一把锁，都是强制同步的

> 5.一个类中，如果同步锁仅仅修饰一部分代码块和方法，那么这个程序实例的非同步锁修饰模块是可以异步执行的。

> 6.当不需要明确的对象作为同步对象，仅仅需要一个区域的代码保持同步时，可以创建一个byte[0]来作为同步的对象，byte[0]是最节省消耗的临时对象

> 7.同步锁的效果不能继承，父类有同步块，子类继承父类后，在子类中调用是没有同步作用的，只用通过super指明调用父类的同步方法或再次用关键字修饰才能实现同步效果

##### 锁的使用的注意事项：实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制

#### 线程和线程通信，进程和进程通信：
* 由于线程和线程之间不可见，进程和进程之间也不可见，但实际的程序设计中，又总会有这样的通信需求，于是Android中设计了一些类和运行机制，用于解决这类的问题

> * 线程和线程之间通信：（同一个应用程序APP之间的通信）
> > * 在同一个应用程序中，只要是全局变量或静态量就都能在程序的任一地方使用，但是由于不同线程之间的执行速度不同，数据同步和正确交互处理会有问题，能够保证程序的正常运行和逻辑实现，只要使用全局变量即能实现跨进程通信
> > * Context,Application,


> * 进程和进程之间通信：（不同应用程序APP之间的通信）
> > * Activity：通过包名+类名启动action可以实现跨应用启动Activity，实现跨应用通信
> > * Content Provider：[自己的博客-Content Provider的简单使用](http://www.cnblogs.com/thinfog/p/5643395.html) 
> > * Broadcast：[自己的博客-Broadcast的简单使用](http://www.cnblogs.com/thinfog/p/5635004.html)
> > * Service：[自己的博客-Service的简单使用](http://www.cnblogs.com/thinfog/p/5634514.html)

##### PS：不同应用程序APP之间的通信，本质上就是在系统中调配数据资源和运行资源，这都需要借助Binder对象来实现，而这种跨进程通信的服务叫AIDL服务。Binder对象是应用程序和系统运行之间沟通的桥梁，无论是应用启动或是跨越进程通信都需要借助Binder对象来实现。
> [Binder机制](https://github.com/GeniusVJR/LearningNotes/blob/master/Part1/Android/Binder%E6%9C%BA%E5%88%B6.md)

> >  * 线程和进程之间通信：
* 任何进程都是要线程去启动的，被线程启动后的进程也会有自己的线程存在，所以说线程和进程通信本质上是线程之间的通信，但不同于同一个应用之间的进程进行通信，因为不同进程中的两个线程拥有不同的内存空间和处理器分配空间，也就是说不同的程序之间不存在全局变量或静态变量，唯一的“全局变量”就是系统，它们同时在一个系统环境下运行。若要通信需要先将信息发送给系统，系统再找到对应的进程中的线程，此时通信的媒介是系统，而系统用来实现这个通信的工具是Binder。

#### Android多线程编程的实际意义与应用：
> * Android开发中多线程的最重要的意义就是将执行程序任务和UI界面显示分割开来，保障UI中的显示一直流畅运行，需要长时间运行的数据操作，都不在UI线程中执行（因为如果在UI中运行数据操作，很容易出现UI线程阻塞，造成UI界面停止而无响应的情况）
> * 在Android中，多线程除了解决了UI流畅性的问题，同样也需要解决跟其他的程序设计一样的线程调度和并发需求，这时的多线程设计基本等同于JAVA

#### 线程管理优化-线程池
#### [线程池程度剖析](http://www.cnblogs.com/devinzhang/p/3856200.html)
> 线程池创立的原因：
> * 线程需要经历开辟内存，执行代码，销毁线程这三个运行阶段，当线程数目多起来的时候，创建线程和销毁线程会占用相当的内存和CPU资源，创建线程池的初衷就是为了减少除了执行之外的消耗，尽可能地将CPU资源放在执行任务上。
> * 方法就是建立线程队列，将需要执行的线程添加进入线程队列里自动执行：每当需要有线程任务运行，就直接创建后添加进线程队列，线程池不断的从队列里取出线程执行，没有需要执行的线程则进进入等待
> * 这样的做法，使得在执行任务的线程数目清晰明了并且可控制，压制了线程数目，也大大减少了每次开启线程都需要新建任务的操作，提升了线程执行的效率，也提升了编程效率
